after meeting with cyrus on 14 april
- get rid of post-fix diamonds
- adding condition for n in the lambda analysis rule
- rename form to shape
- move ap up
- think about whether second clause of thm 2 is a thm 3

http://www.personal.psu.edu/ejp10/blogs/gotunicode/2008/11/glyph-du-jour-thermodynamic-q-.html

from talking to ed:
- reflection?
- am i using the barendregt variable convention

- double check with Cyrus if this is how this how action determinism
  parenthesizes. why do we really need both if t ~ t'?

- none of the theorems say anything about type movement. slightly odd,
  that.

- abstract over constructor pairs in the expression movement stuff and
  write it up. i don't think this works. the idea is that for constructors
  (of either types or exps) that have the same arity, a lot of rules get
  repeated because of the zipper structure. so you want to be able to write
  stuff like

    Test : {tl tr : τ̇}
           (_Cl_ : τ̂ → τ̇ → τ̂)
           (_Cr_ : τ̇ → τ̂ → τ̂) →
           (▹ tl ◃ Cl tr ) + move nextSib +> (tl Cr ▹ tr ◃ )

  so that "any thing that forms a type out of two types moves the same
  way". the problem is that there's a coherence condition between Cl and Cr
  that i don't know how to express. specifically we intend this to be for
  ==>1 and ==>2, but (if we had x1 and x2 for product types) we could apply
  Test ==>1 x2 and get a bullshit movement. i don't know how to encode this
  in the type at the moment.

  solution: judgmental coherence conditions.

     EMoveNextSib : {el er : ė}
          (_Cl_ : ê → ė → ê)
	  (_Cr_ : ė → ê → ê)
	  (cohere : (el Cl er)  ◆e) == ((el Cr er)  ◆e) →
          (▹ el ◃ Cl er ) + move nextSib +> (el Cr ▹ er ◃ )

   this lets us deal with anything


   other approach:

  data match : (ê → ė → ê) → (ė → ê → ê) → Set where
    Match∘ :  (l : ê → ė → ê)
              (r : ė → ê → ê)
              (pl : l == _∘₁_)
              (pr : r == _∘₂_) → match l r
    Match+ :  (l : ê → ė → ê)
              (r : ė → ê → ê)
              (pl : l == _·+₁_)
              (pr : r == _·+₂_) → match l r

  third approach:

   cohere : (Cl == zap1 and Cr == zap2) or (Cl == zplus1 and Cr == zplus2)
   	  (just list out the pairs)





---> talk to ed about reflection
---> talk to frank about frank things

determinism for type synthesis


  iter : List action → ê → ê
  iter [] e = e
  iter (move x :: l) e = {!!}
  iter (del :: l) e = {!!}
  iter (construct x :: l) e = {!!}
  iter (finish :: l) e = {!!}

  reachable : (e1 e2 : ê) (t : {!!}) (same : (e1 ◆e) == (e2 ◆e)) →
               Σ[ αs ∈ List action ] (iter αs e1 == e2)
  reachable = {!!}

  -- constructable : (e : ê)

- reflection: generate mapreduces, so that makes tcomplete and ecomplete
  effectively just

    (mapreduce τ̇) (\ <||> = ⊥ | _ = ⊤) (_×_)
    (mapreduce ė) (\ <||> = ⊥ | <| _ |> = ⊥ | _ = ⊤) tcomplete (_×_)

  generate e^ and t^ from e and t, both erasure erasure functions, matched
  for both. what else?

  -- actdet2 : (Γ : ·ctx) (e e' e'' : ê) (t t' : τ̇) (α : action) →
  --            (Γ ⊢ (e ◆e) => t) →
  --            (Γ ⊢ e => t ~ α ~> e' => t') →
  --            (t ~ t') →
  --            ((Γ ⊢ e ~ α ~> e'' ⇐ t) + (Γ ⊢ e ~ α ~> e'' ⇐ t')) →
  --            (e' == e'')
  -- actdet2 Γ e e' e'' t t' α D1 D2 D3 D45 = {!D3!}
