after meeting with cyrus on 14 april
- get rid of post-fix diamonds
- adding condition for n in the lambda analysis rule
- rename form to shape
- move ap up
- think about whether second clause of thm 2 is a thm 3

http://www.personal.psu.edu/ejp10/blogs/gotunicode/2008/11/glyph-du-jour-thermodynamic-q-.html

from talking to ed:
- reflection?
- am i using the barendregt variable convention

- double check with Cyrus if this is how this how action determinism
  parenthesizes. why do we really need both if t ~ t'?

- none of the theorems say anything about type movement. slightly odd,
  that.

- abstract over constructor pairs in the expression movement stuff and
  write it up. i don't think this works. the idea is that for constructors
  (of either types or exps) that have the same arity, a lot of rules get
  repeated because of the zipper structure. so you want to be able to write
  stuff like

    Test : {tl tr : τ̇}
           (_Cl_ : τ̂ → τ̇ → τ̂)
           (_Cr_ : τ̇ → τ̂ → τ̂) →
           (▹ tl ◃ Cl tr ) + move nextSib +> (tl Cr ▹ tr ◃ )

  so that "any thing that forms a type out of two types moves the same
  way". the problem is that there's a coherence condition between Cl and Cr
  that i don't know how to express. specifically we intend this to be for
  ==>1 and ==>2, but (if we had x1 and x2 for product types) we could apply
  Test ==>1 x2 and get a bullshit movement. i don't know how to encode this
  in the type at the moment.

  solution: judgmental coherence conditions.

     EMoveNextSib : {el er : ė}
          (_Cl_ : ê → ė → ê)
	  (_Cr_ : ė → ê → ê)
	  (cohere : (el Cl er)  ◆e) == ((el Cr er)  ◆e) →
          (▹ el ◃ Cl er ) + move nextSib +> (el Cr ▹ er ◃ )

   this lets us deal with anything


   other approach:

  data match : (ê → ė → ê) → (ė → ê → ê) → Set where
    Match∘ :  (l : ê → ė → ê)
              (r : ė → ê → ê)
              (pl : l == _∘₁_)
              (pr : r == _∘₂_) → match l r
    Match+ :  (l : ê → ė → ê)
              (r : ė → ê → ê)
              (pl : l == _·+₁_)
              (pr : r == _·+₂_) → match l r

  third approach:

   cohere : (Cl == zap1 and Cr == zap2) or (Cl == zplus1 and Cr == zplus2)
   	  (just list out the pairs)
